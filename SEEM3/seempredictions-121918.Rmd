---
title: "Median Exposure Predictions Using the Ring et al. (2019) SEEM Consensus Model"
author: "John Wambaugh"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---
The basic SEEM3 equation is a linear combination of model-predicted exposures from different pathways. That is:

Exposure to chemical $i$ = 
$$= a_0 + \sum_{j=1}^{Npath} \delta_i^j \times \left( a_j + \sum_{k=1}^{Nmodel} m_j^k \times w_k \times p_i^k \right)$$

where 

* $a_0$ represents a "grand mean" exposure over all chemicals; 
* $N_{path}$ represents the number of pathways under consideration; 
* $\delta_i^j$ represents the probability that exposure to chemical $i$ occurs via pathway $j$; 
* $a_j$ represents the additional mean exposure via pathway $j$ over all chemicals (over and above the grand mean); 
* $N_{model}$ represents the number of models under consideration; 
* $m_j^k$ represents whether model $k$ models exposure via pathway $j$ or not (it is either 1 or 0); 
* $w_k$ represents the weight of model $k$; and 
* $p_i^k$ represents the exposure to chemical $i$ predicted by model $k$.

SEEM currently considers three exposure models and four exposure pathways. 

The models are:

1. SHEDS-HT Nearfield Direct Pathway
2. SHEDS-HT Nearfield Indirect Pathway
3. FINE Nearfield Model
4. Food Contact Chemical Migration Model
5. Pesticide Reregistration Eligibility Documents
6. RAIDAR (Far-Field)
7. RAIDAR ICE (Near-Field)
8. USETox Pesticide Scenario
9. USETox Industrial Scenario
10. USETox Residential Scenario
11. USETox Dietary Scenario
12. Production volume
13. Stockholm Convention on POPs

The pathways are:

1. Dietary
2. Near-field
3. Far-field pesticide
4. Far-field industrial 

Models 1 and 7 corresponds to pathway 1, model 2 to pathway 2, and model 3 to pathway 3. Models 4 and 5 correspond to pathway 4, and model 6 to all four pathways.

The data sets for predicting pathway relevance to chemcals are:

Dietary: FDA CEDI list, known NHANES dietary compounds
Near-Field: ExpoCast product deformulation list (Phillips, et al.), CPCPdb (Goldsmith et al.
Far-field pesticde: ACTOR USEdb pesticide list, REDs
Far-field industrial: ACTOR USEdb Industrial-No-Consumer-Use list

The goal of this project is to use Bayesian methods to infer the pathway means ($a_j$) and model weights ($w_k$), given the pathway probabilities ($\delta_i^j$), the model predictions ($p_i^k$), and a matrix of 1's and 0's linking pathways to models ($m_j^k$), along with some "observed" total exposures (exposure rates inferred from NHANES biomonitoring data).

For use later, let's define the number of pathways, the number of models, and the names of the pathways and models.

```{r def_model_path}
rm(list=ls())
SEEMPATH <- "L:/Lab/NCCT_ExpoCast/ExpoCast2018/TSCA-Fire-Drill/SEEM3Predictions"
setwd(SEEMPATH)
MODEL.NAMES <- c("SHEDS.Direct", 
                 "SHEDS.Indirect",
                 "FINE",
                 "Food.Contact",
                 "REDS",
                 "RAIDAR",
                 "RAIDAR.ICE",
                 "USETox.Pest",
                 "USETox.Indust",
                 "USETox.Res",
                 "USETox.Diet",
                 "Production.Volume",
                 "Stockholm")
NUM.MODELS <- length(MODEL.NAMES)

PATHWAY.NAMES <- c("Diet",
                   "Res",
                   "Pest",
                   "Indust")
NUM.PATHWAYS <- length(PATHWAY.NAMES)

PUBLISHED.SUP.TABLE <- "SupTable-all.chem.preds-2018-11-28.txt"
PUBLISHED.CHEM.DESCRIPTORS <- "all-chems-2018-06-04.RData"
DESCRIPTOR.NAMES <- "descriptor-names-2018-06-04.RData"

RF.DATE.USED <- "2018-06-04"
DESC.NAMES <- "descriptor-names-2018-06-04.RData"
NUMBER.TREES <- 5000

MCMC.OUTPUT <- "MCMC-2018-06-05.RData"

# The inferrences were scaled and centered in Step 3:
NHANES.MEAN <- "NHANES-mean-2018-06-05.Rdata"
NHANES.SD <- "NHANES-sd-2018-06-05.Rdata"

# These were used to transform the model predictions in Step 3:
MODEL.MEANS <- "model.means-2018-06-05.RData"
MODEL.SDS <- "model.sds-2018-06-05.RData" 
MODEL.MINS <- "model.mins-2018-06-05.RData"


# Number of samples to use from MCMC:
NUM.DRAWS <- 500

#Number of cores for parallel analysis:
NUM.CORES <- 4


# Manually curated pathways used for the NHANES chemicals:
KNOWN.DELTAS <- "known-deltas-2018-06-05.RData"

# The mapping of models to pathways used in Step 4:
PATHMODEL <- "pathmodel-2018-06-05.RData"
```

Load some R packages for use later.
```{r load_packages, message=FALSE, warning=FALSE}
library(data.table)
library(randomForest)
library(ggplot2)
library(parallel)
library(gdata)
```

Set a seed for reproducibility.
```{r setseed}
TeachingDemos::char2seed("Caroline Ring")
```

Load the chemical descriptors used to build Ring et al. (2019) consensus model:
```{r load_Ring2019descriptors}
all.chems <- readRDS(PUBLISHED.CHEM.DESCRIPTORS)
```

Load the results from Ring et al. (2019) "SEEM3" paper:
```{r load_Ring2019, eval=TRUE}
Ring2019 <- read.csv(PUBLISHED.SUP.TABLE,stringsAsFactors=F)
Ring2019 <- as.data.table(Ring2019)
Ring2019[,Rank:=NULL]
load(DESCRIPTOR.NAMES)
```
Load the chemcials needing predictions:
```{r load_newchems, eval=TRUE}
new.chems <- read.xls("../DSSTox_TSCAACTIVEUNION++_20181203.xlsx",stringsAsFactors=F)
new.chem.props <- read.xls("../TSCAACTIVEUNION++_QR_OPERA.XLSX",stringsAsFactors=F)
new.chems2 <- merge(new.chems,new.chem.props,by.x="DSSTox_Substance_Id",by.y="DTXSID")
new.chems.toxprint <- read.delim("../DSSTox_TSCAACTIVE_CID_TXP.TSV",stringsAsFactors=F)
new.chems.toxprint<- new.chems.toxprint[,1:730]
new.chems.toxprint[,2:730] <- apply(new.chems.toxprint[,2:730],2,as.logical)
new.seem.chems <- merge(new.chems2,new.chems.toxprint,by.x="DSSTox_Structure_Id",by.y="dsstox_compound_id")
new.seem.chems <- as.data.table(new.seem.chems)
new.seem.chems <- new.seem.chems[!duplicated(DSSTox_Substance_Id)]
```

```{r retrievepublished_chems, eval=T}
new.seem.Ring2019 <- Ring2019[dsstox_substance_id%in%new.seem.chems$DSSTox_Substance_Id,]
new.seem.unpredicted <- new.seem.chems[!(DSSTox_Substance_Id%in%Ring2019$dsstox_substance_id),]
```

Adopt property names used in published model
```{R property_names}
physchem.props<-physchem.props[physchem.props!="preferred_name"]
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_AOH..cm3.molecule.sec."]<-"NCCT_AOH"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_BCF"]<-"NCCT_BCF"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_BIODEG.days."]<-"NCCT_BIODEG"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_BP...C."]<-"NCCT_BP"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_HL..atm.m3.mole."]<-"NCCT_HL"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_KM..days."]<-"NCCT_KM"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_LogKOA"]<-"NCCT_LogKOA"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_KOC..L.kg."]<-"NCCT_KOC"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_LogP"]<-"NCCT_LogP"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_MP...C."]<-"NCCT_MP"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_RBiodeg"]<-"NCCT_RBiodeg"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_VP..mmHg."]<-"NCCT_VP"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="OPERA_WS..mol.L."]<-"NCCT_WS"
new.seem.unpredicted[,Structure_MolWt:=as.numeric(Structure_MolWt)]
new.seem.unpredicted[,NCCT_Csatw:=10^(NCCT_WS)*Structure_MolWt*1000]
new.seem.unpredicted[,NCCT_LogKAW := log10((10^NCCT_LogP)/(10^NCCT_LogKOA))]
```
Scale and center all phys-chem.
```{R scale and center}
for (this.col in physchem.props)
{
  print(this.col)
  m <- mean(unlist(all.chems[,this.col,with=F]),na.rm=T)
  s <- sd(unlist(all.chems[,this.col,with=F]),na.rm=T)
 #Use means where there is an NA:
  new.seem.unpredicted[is.na(unlist(new.seem.unpredicted[,this.col,with=F])),this.col] <- m
# Scale and center the phys-chem properties:
  new.seem.unpredicted[,this.col] <- (unlist(new.seem.unpredicted[,this.col,with=F]) - m)/s
}

```
Convert all the logical variables to factors, for random forest.

```{r convert_logic_factor, eval=TRUE}
logic.names <- names(all.chems)[all.chems[, sapply(.SD, is.logical)]]
all.chems[, (logic.names):=lapply(.SD,
                                  function(x) factor(x,
                                                     levels=c(TRUE, FALSE))),
          .SDcols=logic.names]
new.seem.unpredicted[, (logic.names):=lapply(.SD,
                                  function(x) factor(x,
                                                     levels=c(TRUE, FALSE))),
          .SDcols=logic.names]
for (this.col in logic.names) levels(new.seem.unpredicted[,this.col]) <- levels(all.chems[,this.col])
```

```{R make_random_forest_predictions, eval=T}
rm(all.chems)
load(DESC.NAMES)
rf_vars <- c(structure.desc, physchem.props)
rf_vars <- rf_vars[!(rf_vars %in% c("COMMON.NAME","preferred_name"))]

delta.preds<-NULL
for (this.pathway in PATHWAY.NAMES)
{
  gc()
  print(paste("Random forest for", this.pathway))
  deltaname <- paste("delta",
                     this.pathway,
                     sep=".")
  this.RF <-   readRDS(paste("delta",
                this.pathway,
                "forest_noimpute-",RF.DATE.USED,".Rdata",
                sep="_"))
  
  delta.pred <- predict(object=this.RF,
                        newdata=new.seem.unpredicted[,
                                          .SD, 
                                          .SDcols=rf_vars],
                        type="prob")
  rownames(delta.pred) <- new.seem.unpredicted[, DSSTox_Substance_Id]
  
  delta.pred <- data.table(delta.pred, keep.rownames=TRUE)
  delta.pred[,"FALSE":=NULL]
  setnames(delta.pred, 
           c("rn", "TRUE"),
           c("DSSTox_Substance_Id", paste("delta",
                          this.pathway,
                          "pred",
                          sep=".")))
  #Add OOB error rate
  delta.pred[, (paste("delta",
                      this.pathway,
                      "OOB.err",
                      sep=".")):=this.RF$err.rate[NUMBER.TREES, "OOB"]]
  if (!is.null(delta.preds)) delta.preds<-merge(delta.preds,delta.pred,by="DSSTox_Substance_Id",allow.cartesian=TRUE)
  else delta.preds <- delta.pred
}
new.seem.unpredicted<-merge(new.seem.unpredicted,delta.preds,by="DSSTox_Substance_Id",allow.cartesian=TRUE)
```
Write out the chemical descriptors wtih pathway predictions added:
```{r, eval=TRUE}
gc()
saveRDS(new.seem.unpredicted, paste("new-chems-deltas-",Sys.Date(),".Rdata",sep=""))
```


# Initialize model predictions (all NA's except Stockholm and production volume)
```{R set model predictions to zero}
for (this.model in MODEL.NAMES) 
{
  new.seem.unpredicted[,eval(this.model):=as.numeric(NA)]
#  new.seem.unpredicted[,eval(this.model):=as.numeric(eval(this.model))]
}
new.seem.unpredicted[,Stockholm:=0]
```
Load production Volume data
```{R production_volume}
CDR.HPV <- read.xls("CDR-HPV-2016.xlsx",stringsAsFactors=FALSE)
CDR.HPV <- subset(CDR.HPV,DSSTox_Substance_Id!="")
CDR.HPV$CAS <- CDR.HPV$Substance_CASRN
CDR.HPV$Compound <- CDR.HPV$Substance_Name


#Convert CDR categories (lbs/year) into kg/day
CDR.to.geometric.mean <- function(x)
{
  if (x == "Withheld")
 # Assume somewhere between 500,000 lbs and 1 billion lbs):
    return(exp((log(25000)+log(5*10^11))/2)/2.204/365.25)
  else if (x == "< 25,000 lb")
    return(25000/2/2.204/365.25)
  else if (x == ">200,000,000,000 lb")
    return(5*10^11/2.204/365.25)
  else if (regexpr(" - ",x)!=-1)
  {
    temp <- strsplit(x," ")[[1]]
    lower.bound <- as.numeric(gsub(",","",temp[1]))
    upper.bound <- as.numeric(gsub(",","",temp[3]))
    return(exp((log(lower.bound)+log(upper.bound))/2)/2.204/365.25)
  } else print(CDR.HPV[this.row,"CHEM_AGG_P"])
}


CDR.HPV <- cbind(CDR.HPV,unlist(lapply(as.list(CDR.HPV$X2015.Aggregate.PV..Lbs..),CDR.to.geometric.mean)))
colnames(CDR.HPV)[length(colnames(CDR.HPV))] <- "kgs.day"
for (this.chem in CDR.HPV$DSSTox_Substance_Id) if (this.chem %in% new.seem.unpredicted$DSSTox_Substance_Id) new.seem.unpredicted[DSSTox_Substance_Id==this.chem,Production.Volume:=CDR.HPV[CDR.HPV$DSSTox_Substance_Id==this.chem,"kgs.day"]]
new.seem.unpredicted[is.na(Production.Volume),Production.Volume:=25000/2/2.204/365.25]
```
```{R rename_model_pres,EVAL=T}
new.seem.unpredicted <- subset(new.seem.unpredicted,!is.na(delta.Diet.pred)&!is.na(delta.Res.pred)&!is.na(delta.Pest.pred)&!is.na(delta.Indust.pred))

new.seem.unpredicted <- new.seem.unpredicted[,c("DSSTox_Substance_Id","Substance_CASRN","Substance_Name",MODEL.NAMES,paste("delta",PATHWAY.NAMES,"pred",sep=".")),with=F]
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="DSSTox_Substance_Id"]<-"dsstox_substance_id"
colnames(new.seem.unpredicted)[colnames(new.seem.unpredicted)=="Substance_CASRN"]<-"CAS"

setnames(new.seem.unpredicted,
         MODEL.NAMES,
         paste("Pred",
               MODEL.NAMES,
               sep="."))
```
```{r SEEMpredictior}
deltas <- paste("delta",PATHWAY.NAMES,"pred",sep=".")
preds <- paste("Pred",MODEL.NAMES,"log.scale",sep=".")


fast_seem <- function(x)
{
  delta.vec <- unlist(chem.preds[dsstox_substance_id==x,deltas,with=F])
  names(delta.vec) <- PATHWAY.NAMES
  # replicate predictions based on number of times they occur in each pathway:
  pred.vec <- unlist(chem.preds[dsstox_substance_id==x,preds,with=F])[wmdl]
  chem.delta.draws <- matrix(NA,nrow=NUM.DRAWS,ncol=NUM.PATHWAYS)
  colnames(chem.delta.draws) <- PATHWAY.NAMES
  for (i in PATHWAY.NAMES)
  {
    chem.delta.draws[,i] <- rbinom(NUM.DRAWS,1,delta.vec[i])
  }
 # weightedpreds <- (chem.delta.draws[,wpath]*sub.samp[,(2+NUM.PATHWAYS):(1+NUM.PATHWAYS+NUM.NONZERO.WEIGHTS)])%*%pred.vec
  means <- apply(chem.delta.draws*sub.samp[,2:(1+NUM.PATHWAYS)],1,sum)
  weightedpreds <-as.matrix(chem.delta.draws[,wpath]*sub.samp[,(2+NUM.PATHWAYS):(1+NUM.PATHWAYS+NUM.NONZERO.WEIGHTS)])%*%pred.vec
  return(sub.samp[,1]+means+weightedpreds)
}



```
# Predictions for All Chemicals
```{r}
load(MCMC.OUTPUT)
load(PATHMODEL)

set.seed(123456)
these.iter <- sample(1:dim(samp.dt)[1],NUM.DRAWS)
sub.samp <- samp.dt[these.iter]
sub.samp[,iteration:=NULL]
sub.samp <- as.matrix(sub.samp)
model.mins <- readRDS(MODEL.MINS)

model.means <- readRDS(MODEL.MEANS)
model.sds <- readRDS(MODEL.SDS) 


a <- new.seem.unpredicted
for (this.model in MODEL.NAMES)
{
  scalenm <- paste("Pred",this.model,"log",sep=".")
  colnm <- paste("Pred",this.model,"log.scale",sep=".")
  a[,eval(colnm):=(log(as.numeric(unlist(a[,paste("Pred",this.model,sep="."),with=F])))-model.means[scalenm])/model.sds[scalenm]]
  a[is.na(unlist(a[,colnm,with=F])),colnm] <- 0
  if (any(unlist(a[,colnm,with=F])==-Inf))
  {
    a[unlist(a[,colnm,with=F])==-Inf,colnm] <- model.mins[colnm]
  }
}
a[,Pred.Stockholm.log.scale:=Pred.Stockholm]


chem.preds <- a

known.delta.matrix <- readRDS(KNOWN.DELTAS)
for (this.chem in rownames(known.delta.matrix))
  for (this.path in colnames(known.delta.matrix))
    chem.preds[dsstox_substance_id==this.chem,paste("delta",this.path,"pred",sep="."):=known.delta.matrix[this.chem,this.path]]

cl <-makeCluster(NUM.CORES)
clusterCall(cl,setwd,SEEMPATH)
clusterSetRNGStream(cl, 123456)
clusterExport(cl,c("fast_seem","chem.preds","PATHWAY.NAMES","MODEL.NAMES","NUM.MODELS","NUM.DRAWS","NUM.PATHWAYS","sub.samp","deltas","preds","wmdl","wpath","NUM.NONZERO.WEIGHTS"))
clusterEvalQ(cl,library(data.table))


#seem.preds <-  matrix(unlist(lapply(as.list(chem.preds$dsstox_substance_id), function(x) quantile(unlist(fast_seem(x)),c(0.5,0.025,0.975)))),ncol=3,byrow=T)
seem.preds <-  matrix(unlist(parLapply(cl,as.list(chem.preds$dsstox_substance_id), function(x) quantile(unlist(fast_seem(x)),c(0.5,0.025,0.975)))),ncol=3,byrow=T)
stopCluster(cl)
save(seem.preds,file=paste("seem-preds-",Sys.Date(),".RData",sep=""))
#Convert back to the mg/kg/day scale:
nhanes.mean <- readRDS(NHANES.MEAN)
nhanes.sd <- readRDS(NHANES.SD) 
seem.preds <- seem.preds*nhanes.sd+nhanes.mean

chem.preds[,seem3:=exp(seem.preds[,1])]
chem.preds[,seem3.l95:=exp(seem.preds[,2])]
chem.preds[,seem3.u95:=exp(seem.preds[,3])]
```
```{R annote_pathways}
chem.preds[,Pathway:=""]
chem.preds[delta.Diet.pred>0.5,Pathway:=paste(Pathway,"Dietary",sep=", ")]
chem.preds[delta.Res.pred>0.5,Pathway:=paste(Pathway,"Consumer",sep=", ")]
chem.preds[delta.Pest.pred>0.5,Pathway:=paste(Pathway,"Pesticide",sep=", ")]
chem.preds[delta.Indust.pred>0.5,Pathway:=paste(Pathway,"Industrial",sep=", ")]
chem.preds[,Pathway:=substr(Pathway,3,nchar(Pathway))]
chem.preds[Pathway=="",Pathway:="Unknown"]
chem.preds[Pathway=="Dietary, Consumer, Pesticide, Industrial",Pathway:="All Four"]
chem.preds[regexpr(",",Pathway)!=-1,Pathway:=gsub("Consumer","Cons.",gsub("Industrial","Ind.",gsub("Dietary","Diet.",gsub("Pesticide","Pest.",Pathway))))]

chem.preds[,AD:=1]
chem.preds[delta.Diet.pred<=0.5 &
           delta.Res.pred<=0.5 &
           delta.Pest.pred<=0.5 &
          delta.Indust.pred<=0.5,AD:=0]
chem.preds[delta.Diet.pred<=0.5 &
           delta.Res.pred<=0.5 &
           delta.Pest.pred<=0.5 &
          delta.Indust.pred<=0.5,seem3.u95:=NA]
chem.preds[,Rank:=NA]
chem.preds[AD==1,Rank:=1+dim(subset(chem.preds,AD==1))[1]-rank(seem3.u95)]


setwd(SEEMPATH)
save(chem.preds,file=paste("new.chem.preds-",Sys.Date(),".RData",sep=""))
```